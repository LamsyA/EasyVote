//SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/Counters.sol";

contract Voting {
    using Counters for Counters.Counter;

    Counters.Counter public _voterId;
    Counters.Counter public _candidateId;

    bool started;
    bool ended;

    /*<---------------------Election Status---------------->*/
    constructor() {
        admin = msg.sender;
        started = false;
        ended = true;
    }

    address public admin;

    modifier onlyAdmin() {
        require(
            admin == msg.sender,
            "This is an admin function, Please Contact admin"
        );
        _;
    }

    function endElection() public onlyAdmin {
        require(started == true && ended == false);

        started = false;
        ended = true;
    }

    function startElection() public {
        require(msg.sender == admin, "Only Admin can start Election");
        require(started == false && ended == true);

        started = true;
        ended = false;
    }

    function getElectionStatus() public view returns (string memory) {
        if (started == true && ended == true) {
            return "Voting has finished";
        }

        if (started == true && ended == false) {
            return "Voting in Progress";
        }

        return "Voting not-started";
    }

    /* <-----------------------Candidate Details---->  */
    struct Candidate {
        uint256 candidateId;
        uint256 age;
        string name;
        uint256 voteCount;
        address _address;
        string ipfs;
    }

    event CreateCandidate(
        uint256 indexed candidateId,
        uint256 age,
        string name,
        uint256 voteCount,
        address _address,
        string ipfs
    );

    struct statcandidate{
        uint totalcandidates;
        uint totalVote;
        uint totalVoter;
    }

  //  address[] public candidateAddress;
    mapping(address => Candidate[]) public candidatesMap;
    Candidate[] candidates;
    mapping(uint => bool) CandidateExist;
    mapping(uint => bool) voterExist;
    //<----------------voters details----------->

    address[] public votedVoters;
    address[] public votersAddress;
    mapping(address => Voter[]) public votersMap;
    Voter[] voters;
    


    struct Voter {
        uint256 voter_voterId;
        string voter_name;
        address voter_address;
        uint256 voter_age;
        uint256 voter_allowed;
        bool voter_voted;
        uint256 voter_vote;
        string voter_ipfs;
    }
    event CreatedVoter(
        uint256 indexed voter_voterId,
        string voter_name,
        address voter_address,
        uint256 voter_age,
        uint256 voter_allowed,
        bool voter_voted,
        uint256 voter_vote,
        string voter_ipfs
    );

    function addCandidate(
        uint256 _age,
        string memory _name,
        address _address,
        string memory _ipfs
    ) public onlyAdmin returns (bool) {
        require(
            ended == true,
            "You can not add candidate when election is in progress"
        );
        _candidateId.increment();
        uint256 idNumber = _candidateId.current();

        Candidate memory candidate ;

        candidate.age = _age;
        candidate.name = _name;
        candidate.candidateId = idNumber;
        candidate.voteCount = 0;
        candidate._address = _address;
        candidate.ipfs = _ipfs;

        candidates.push(candidate);
        candidatesMap[_address].push(candidate);
        CandidateExist[idNumber] =true;
       // candidateAddress.push(_address);

        emit CreateCandidate(
            idNumber,
            _age,
            _name,
            candidate.voteCount,
            _address,
            _ipfs
        );
        return true;
    }

    function getCandidate() public view returns (Candidate[] memory) {
        return candidates;
    }


    function getVoter() public view returns (Voter[] memory) {
        return voters;
    }

    function voteRight(
        string memory _name,
        string memory _ipfs,
        uint256 _age
    ) public
    returns(bool)
     {
        require(started == false, "Election in progress, Right revoked!");
        require(_age >= 18, "Ops! You are underage");

        _voterId.increment();

        uint256 idNumber = _voterId.current();
        Voter memory voter   ;
        require(voter.voter_allowed == 0);

        voter.voter_allowed = 1;
        voter.voter_name = _name;
        voter.voter_address = msg.sender;
        voter.voter_age = _age;
        voter.voter_voterId = idNumber;
        voter.voter_vote = 1000;
        voter.voter_voted = false;
        voter.voter_ipfs = _ipfs;

         voters.push(voter);
        votersMap[msg.sender].push(voter);
        voterExist[idNumber] =true;
   

        emit CreatedVoter(
            idNumber,
            _name,
            msg.sender,
            _age,
            voter.voter_allowed,
            voter.voter_voted,
            voter.voter_vote,
            _ipfs
        );
        return true;
    }

    function vote( uint256 candidateVoteId,uint idNumber, address _address) public {
        Voter memory voter ;
  
        require(voterExist[idNumber] =true,"Provide a valid Id");
        require(!voter.voter_voted, "You have already voted");
        require(
            started == true,
            "You cannot vote now, wait till the poll is opened for voting"
        );
     //   require(voter.voter_allowed != 0, "you have no right to vote");

        voter.voter_voted = true;
        voter.voter_vote = candidateVoteId;

        votedVoters.push(msg.sender);
          voters.push(voter);
        votersMap[msg.sender].push(voter);
        

        Candidate memory candidate ;

         candidate.voteCount +1;
        voter.voter_vote = candidateVoteId;

           candidates.push(candidate);
         candidatesMap[_address].push(candidate);
       // CandidateExist[idNumber] =true;
    }
    

    function getVoterLength() public view returns (uint256) {
        return votersAddress.length;
    }


    function getVotedVoterList() public view returns (address[] memory) {
        return votedVoters;
    }

    function getVoterList() public view returns (address[] memory) {
        return votersAddress;
    }
}
